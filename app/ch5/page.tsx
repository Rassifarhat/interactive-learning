'use client';
import React, { useEffect, useRef, useState } from 'react';
import * as d3 from 'd3';

// Define TypeScript interfaces for our data structure
interface MindmapNode {
  name: string;
  id: string; // Unique identifier for the node
  summary?: string; // Optional detailed description
  children?: MindmapNode[];
}

// Define the structure returned by d3.hierarchy
interface HierarchyNode extends d3.HierarchyNode<MindmapNode> {}

// Define the structure for links generated by d3
interface HierarchyLink extends d3.HierarchyLink<MindmapNode> {}

// Define the main component
const ChapterFiveMindmap: React.FC = () => {
  const svgRef = useRef<SVGSVGElement>(null);
  const [infoContent, setInfoContent] = useState<string>('');
  const [activeNode, setActiveNode] = useState<string | null>(null);
  const [zoom, setZoom] = useState<number>(1);
  const zoomRef = useRef<d3.ZoomBehavior<SVGSVGElement, unknown> | null>(null);

  // Zoom control handlers
  const handleZoomIn = () => {
    if (svgRef.current && zoomRef.current) {
      d3.select(svgRef.current)
        .transition()
        .duration(300)
        .call(zoomRef.current.scaleBy, 1.3);
    }
  };

  const handleZoomOut = () => {
    if (svgRef.current && zoomRef.current) {
      d3.select(svgRef.current)
        .transition()
        .duration(300)
        .call(zoomRef.current.scaleBy, 0.7);
    }
  };

  const handleReset = () => {
    if (svgRef.current && zoomRef.current) {
      const width = 1200;
      const height = 800;
      d3.select(svgRef.current)
        .transition()
        .duration(500)
        .call(
          zoomRef.current.transform,
          d3.zoomIdentity.translate(width / 2, height / 2).scale(0.8)
        );
    }
  };

  // Transformed data structure for Chapter 5 (Alkenes)
  const data: MindmapNode = {
    name: "Alkenes (Topic 5)",
    id: "alkenes",
    summary: "**Key Concepts:**\n- General formula: C_n_H_2n_ (non-cyclic)\n- Structure: Contain at least one C=C double bond\n- Trigonal planar geometry: Bond angles ~120°\n**Exam Tips:**\n- Always identify the C=C bond first - it's the reactive site!\n- Cycloalkenes formula C_n_H_2n-2_\n- Show C=C with 120° angles\n**Common Mistakes:**\n- Confusing alkanes and alkenes\n- Forgetting double bonds need 2 fewer H atoms",
    children: [
      {
        name: "5A.1 Alkene Bonding",
        id: "bonding",
        summary: "**Key Concepts:**\n- Double bond: Sigma (σ) bond (strong) + Pi (π) bond (weak, reactive)\n- Hybridization: sp2\n- Geometry: Trigonal planar (120°)\n**Exam Tips:**\n- Sketch π bond above/below plane\n- π bond vulnerable to electrophiles\n- Restricted rotation around C=C -> stereoisomerism\n*Pi bonds: sideways p-orbital overlap. Rotation breaks pi bond.*",
        children: []
      },
      {
        name: "5A.2 Geometric Isomerism",
        id: "isomerism",
        summary: "**Key Concepts:**\n- Cause: Restricted C=C rotation\n- Requirement: Each C has 2 different groups\n- Types: E (opposite), Z (same side) priority groups\n**Exam Tips:**\n- Use Cahn-Ingold-Prelog rules for priority\n- Higher atomic number = higher priority\n- Draw clear E/Z diagrams\n- Use E/Z unless groups are identical (then cis/trans)\n**Common Mistakes:**\n- Using cis/trans for different groups\n- Incorrect priority assignment\n*Memorization Tip: E='Enemies'(opposite), Z='Zusammen'(together)*",
        children: []
      },
      {
        name: "5A.3 Addition Reactions",
        id: "addition",
        summary: "**Key Reactions:**\n- Hydrogenation: + H2 → C-C (Ni, 150°C)\n- Halogenation: + X2 → X-C-C-X (X=Br,Cl)\n- Hydrogen halides: + HX → C-C-X (Markovnikov)\n- Hydration: + H2O → C-C-OH (H3PO4 catalyst)\n- Oxidation: + [O] + H2O → C(OH)-C(OH) (KMnO4)\n**Exam Tips:**\n- Test for C=C: Bromine water decolorization\n- Markovnikov's Rule: H adds to C with more H atoms\n- Write balanced equations + conditions\n**Common Mistakes:**\n- Forgetting catalysts/conditions\n- Incorrect Markovnikov application\n- Confusing hydration & hydrogenation",
        children: [
          {
            name: "5A.4 Electrophilic Addition Mechanism",
            id: "mechanism",
            summary: "**Mechanism Steps:**\n1. Electrophile (E+) attacks π bond -> forms carbocation intermediate\n2. Nucleophile (Nu-) attacks carbocation -> forms C-Nu bond\n**Exam Tips:**\n- Use curly arrows correctly (start from electron source)\n- Show intermediates & charges\n- Carbocation forms at more substituted C (Markovnikov)\n- Show heterolytic fission\n**Common Mistakes:**\n- Incorrect arrows\n- Missing carbocation/charges\n- Incorrect carbocation position\n*Tip: Carbocation stability: 3° > 2° > 1° (explains Markovnikov)*",
            children: []
          }
        ]
      },
      {
        name: "5B.1 Addition Polymerisation",
        id: "polymerisation",
        summary: "**Key Concepts:**\n- Process: Alkene monomers join via double bonds\n- Conditions: High P, high T, catalyst\n- Result: Long chain repeating units\n**Common Polymers:**\n- Ethene → Poly(ethene)\n- Propene → Poly(propene)\n- Chloroethene → Poly(chloroethene) (PVC)\n- Tetrafluoroethene → PTFE\n**Exam Tips:**\n- Draw repeat units in [ ] with bonds extending out\n- Identify monomer from polymer & vice versa\n- Use subscript 'n'\n**Common Mistakes:**\n- Incorrect repeat unit drawing\n- Confusing addition/condensation polymers\n- Incorrect monomer/polymer structure conversion",
        children: [
          {
            name: "5B.2 Environmental Concerns",
            id: "environment",
            summary: "**Key Problems:**\n- Non-biodegradable\n- Waste accumulation (landfills, oceans)\n- Toxic emissions on incineration\n**Solutions:**\n- Recycling (thermoplastics)\n- Incineration (energy recovery)\n- Biodegradable alternatives (e.g., PLA)\n- Reducing usage\n**Exam Tips:**\n- Discuss pros/cons of solutions\n- Link to sustainability\n- Use specific examples\n*Evaluation is key - discuss trade-offs.*",
            children: []
          }
        ]
      }
    ]
  };

  useEffect(() => {
    if (!svgRef.current || !data) return;

    const width = 1200;
    const height = 800;
    const radius = Math.min(width, height) / 2 * 0.8;

    const svg = d3.select(svgRef.current)
      .attr('width', width)
      .attr('height', height)
      .attr('viewBox', [-width / 2, -height / 2, width, height])
      .style('font', '10px sans-serif');

    // Clear previous render
    svg.selectAll('*').remove(); 

    // Create root container for zoom/pan
    const g = svg.append('g');

    // Define the tree layout generator for radial layout
    const tree = d3.tree<MindmapNode>()
      .size([2 * Math.PI, radius])
      .separation((a, b) => (a.parent == b.parent ? 1 : 2) / a.depth);

    // Create the hierarchy from the data
    const root = tree(d3.hierarchy(data)
        .sort((a, b) => d3.ascending(a.data.name, b.data.name)));

    // Set up zoom behavior
    zoomRef.current = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.2, 3]) // Zoom limits
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
        setZoom(event.transform.k);
      });

    // Apply zoom to the SVG element
    svg.call(zoomRef.current);

    // Initial transform: Center the graph and apply initial scale
    const initialTransform = d3.zoomIdentity.translate(width / 2, height / 2).scale(0.8);
    svg.call(zoomRef.current.transform, initialTransform);
    g.attr('transform', initialTransform.toString());


    // Links
    g.append('g')
      .attr('fill', 'none')
      .attr('stroke', '#555')
      .attr('stroke-opacity', 0.4)
      .attr('stroke-width', 1.5)
      .selectAll('path')
      .data(root.links())
      .join('path')
      .attr('d', d3.linkRadial<d3.HierarchyLink<MindmapNode>, d3.HierarchyPointNode<MindmapNode>>()
          .angle(d => d.x)
          .radius(d => d.y));

    // Nodes
    const node = g.append('g')
      .selectAll('g')
      .data(root.descendants())
      .join('g')
      .attr('transform', d => `rotate(${d.x * 180 / Math.PI - 90}) translate(${d.y},0)`);

    node.append('circle')
      .attr('r', 4.5)
      .attr('fill', d => d.children ? '#555' : '#999')
      .attr('stroke', '#fff')
      .attr('stroke-width', 1.5)
      .style('cursor', 'pointer')
      .on('click', (event, d) => {
        // Update info content on click
        setInfoContent(d.data.summary || d.data.name);
        setActiveNode(d.data.id); // Set active node id

        // Prevent zoom trigger on node click
        event.stopPropagation();
      });

    // Text labels
    node.append('text')
      .attr('dy', '0.31em')
      .attr('x', d => d.x < Math.PI === !d.children ? 6 : -6)
      .attr('text-anchor', d => d.x < Math.PI === !d.children ? 'start' : 'end')
      .attr('transform', d => d.x >= Math.PI ? 'rotate(180)' : null)
      .text(d => d.data.name)
      .clone(true).lower()
      .attr('stroke', 'white');

  }, [data]); // Rerun effect if data changes

  return (
    <div style={{ display: 'flex', height: '100vh', flexDirection: 'column' }}>
      <div style={{ display: 'flex', padding: '10px', borderBottom: '1px solid #ccc' }}>
        {/* Info Display Area */}
        <div style={{ flexGrow: 1, marginRight: '10px', padding: '10px', border: '1px solid #eee', borderRadius: '4px', minHeight: '80px', maxHeight: '200px', overflowY: 'auto', backgroundColor: '#f9f9f9' }}>
          {infoContent ? (
            <div dangerouslySetInnerHTML={{ __html: infoContent.replace(/\n/g, '<br />') }} />
          ) : (
            <p>Click on a node to see details.</p>
          )}
        </div>
        {/* Zoom Controls */}
        <div style={{ display: 'flex', flexDirection: 'column', justifyContent: 'center' }}>
          <button onClick={handleZoomIn} style={{ marginBottom: '5px' }}>Zoom In (+)</button>
          <button onClick={handleZoomOut} style={{ marginBottom: '5px' }}>Zoom Out (-)</button>
          <button onClick={handleReset}>Reset</button>
        </div>
      </div>
      <div style={{ flexGrow: 1, overflow: 'hidden' }}>
        <svg ref={svgRef}></svg>
      </div>
    </div>
  );
};

export default ChapterFiveMindmap;
